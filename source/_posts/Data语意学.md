---
title: Data 语意学
tags:
  - C++
  - 书摘
categories:
  - C++
date: 2015-03-02 23:03:46
---

## C++类对象的大小

### 一个实例引出的思考
```
class X{};
class Y:virtual public X{};
class Z:virtual public X{};
class A:public Y, public Z{};
```
猜猜sizeof上面各个类都为多少？

Lippman的一个法国读者的结果是：
```
sizeof X yielded 1                         
sizeof Y yielded 8                         
sizeof Z yielded 8                         
sizeof A yielded 12   
```
我在vs2012上的结果是：
```
sizeof X yielded 1   
sizeof Y yielded 4   
sizeof Z yielded 4    
sizeof Z yielded 8       
```
当我们对于C++对象的内存布局知之甚少的情况下，想搞清这些奇怪现象的缘由将是一件非常困难的事情。不过下文会为你一一解惑。

事实上，对于像X这样的一个的空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？

我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。

alignment[^注1]会将数值调整到某数的整数倍，32位计算机上位4bytes。内存对齐可以使得总线的运输量达到最高效率。所以Y、Z的大小被补齐到8就不足为奇了。

那么在vs2012中为什么Y、Z的大小是4而不是8呢？我们先思考一个问题，X之所以被插入1字节是因为本身为空，需要这一个字节为其在内存中给它占领一个独一无二的地址。但是当这一字节被继承到Y、Z后呢？它已经完全失去了它存在的意义，为什么？因为Y、Z各自拥有一个虚基类指针，它们的大小不是0。既然这一字节在Y、Z中毫无意义，那么就没必要留着。也就是说vs2010对它们进行了优化，优化的结果是去掉了那一个字节,而Lippman的法国读者的编译器显然没有做到这一点。

当我们现在再来看A的时候，一切就不是问题了。对于那位Lippman的法国读者来说，A的大小是共享的X实体1字节,X和Y的大小分别减去虚基类带来的内存空间，都是4。A的总计大小为9，alignment以后就是12了。而对于vs2010来说，那个一字节被优化后，A的大小为8，也不需再进行alignment操作。


### 影响C++类的大小的三个因素：

- 支持特殊功能所带来的额外负担（对各种virtual的支持）。
- 编译器对特殊情况的优化处理。
- alignment操作，即内存对齐。[关于更多的memory alignment（内存对齐）的知识见VC内存对齐准则（Memory alignment）]

## VC内存对齐准则（Memory alignment）

本节所有内容在建立在一个前提下：使用VC编译器。着重点在于：VC的内存对齐准则；同样的数据，
不同的排列有不同的大小，另外在有虚函数或虚拟继承情况下又有如何影响？

### 内存对齐

对于一台32位的机器来说如何才能发挥它的最佳存取效率呢？当然是每次都读4字节（32bit）,这样才可以让它的bus处于最高效率。实际上它也是这么做的，即使你只需要一个字节，它也是读一个机器字长（这儿是32bit）。更重要的是，有的机器在存取或存储数据的时候它要求数据必须是对齐的，何谓对齐？它要求数据的地址从4的倍数开始，如若不然，它就报错。还有的机器它虽然不报错，但对于一个类似int变量，假如它横跨一个边界的两端，那么它将要进行两次读取才能获得这个int值。比方它存储在地址为2~5的四个字节中，那么要读取这个int，将要进行两次读取，第一次读取0~3四个字节，第二次读取4~7四个字节。但是如果我们把这个整形的起始地址调整到0,4,8…呢？一次存取就够了！这种调整就是内存对齐了。我们也可以依次类推到16位或64位的机器上。

### 边界该如何调整

对于32位的机器来说，它当然最渴望它的数据的大小都是4 Byte或者4的倍数Byte，这样它就能最有效率的存取数据，当然如果数据小于4Byte,那也是没问题的。那么编译器要做的便是尽量满足这个要求。

这两天我断续对VC做了一些实验，并总结如下三条准则，你要明白的是这并非来自微软的官方文档，但我自以为这些准则或许不全但应该都是正确的：

- 变量存放的起始位置^注2应为变量的大小与规定对齐量[^注1]中较小者的倍数。例如，假设规定对齐量为4，那么char（1byte）变量应该存储在偏移量为1的倍数的地方，而整形变量（4byte）则是从偏移量为4的倍数的地方，而double（8 byte）也同样应存储在偏移量为4的倍数的地方，为什么不是8？因为规定对齐量默认值为4，而4 < 8。在VC中默认对齐量为8，而非4。
- 结构体整体的大小也应该对齐，对齐依照规定对齐量与最大数据成员两者中较小的进行。
- Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响。一个实例

对于类T：

```
class T {
    char c;
    int i;
    double  d;
}
```
将其sizeof输出后的大小为16，其内存布局如图T.变量c从偏移量为0开始存储，而整形i第一个符号条件的偏移量为4，double型d的第一个符号条件的为8。整个对象的大小为16，不需要再进行额外的对齐。

类T 的内存布局
![](/images/cpp/cpp_8.png)


同样的数据，不同的大小

再看类L,它与T存储同样类型的数据，仅仅是顺序不同罢了，那么它sizeof输出的大小是多少呢?

类L:
```
class L {
    char c;
    double  d;
    int i;
}
```
它sizeof后的结果或许会令你大吃一惊，或许不会（如果你有认真读前面的两条准则）。Lsizeof后的结果是24！同样是一个int，一个char，一个double却整整多出了8个字节。这期间发生了什么？我们依据前面两条规则来看看。C存储于0的位置，1~7都不能整除8，所以d存储在8~15，16给i正好合适，i存储在16~19。总共花费了20个字节，抱歉不是8的倍数，还得补齐4个。现在你可以看看图L的关于类L的内存布局，再比较一下类L和类T的内存布局。

图L(类L的布局)
![](/images/cpp/cpp_9.png)


我得出了这样一条并不权威的结论，因为我还没听有人这样说过：在声明数据成员的时候，将最大字节数的变量放在最前面[^注3],切忌不要将大小差距很大的类型交替声明。

### Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响

前面的实例只涉及前两条准则，现在我们来看看第三条的两个实例：
```
class X{char a;};
class Y: virtual public X{};
```
Y的大小为:a占一个字节，VbcPoint（我称他为虚基类指针）占四个字节。我们不论a与VbcPoint的位置如何摆放，如果将VbcPoint等同于一个成员数据来看的话，sizeof(Y)都应该为8.实际上它是5！就我目前的水平，我只能先将其解释为VbcPoint不参与对齐。

对于vptr这个问题则不存在：

```
class X{
    char a;
    virtual int vfc(){};}
sizeof（X）的大小确实为8.
```
关于#pragma pack(n)

用#pragma pack(n)改变规定对齐量试试眨眼。


使我确信从大到小排列好于从小到大排列的理由在于，从大到小排列一般无需成员之间的对齐，唯一的对齐工作是最后进行的整个结构体对齐的工作。毫无疑问的是，这应该是最节省内存的方式。再之后，独酌提出从小到大可能好些，虽然没有给出有说服力的理由，但却使我无比困惑，我当时虽然认为从大到小的排列更有优势，但却实在想不出一个实例能使得它优于从小到大排列的。不过最终我击垮了自己的理由，在继承状况下从大到小排列很容易被打破，比方，基类的成员为一个char,继承类的成员为double,int,char虽然基类和继承类都是按从大到小的顺序排列的，但是继承类的内存布局最终会使char,double,int,char，此时既不能避免成员对齐，又导致后面的结构体对齐。暂时获得的最终结果是从小到大排列是更好的一种排列方式。

## C++对象的数据成员

### 数据成员的布局

对于一个类来说它的对象中只存放非静态的数据成员,但是除此之外，编译器为了实现virtual功能还会合成一些其它成员插入到对象中。我们来看看这些成员的布局。

### C++ 标准的规定

- 在同一个Access Section（也就是private,public,protected片段）中，要求较晚出现的数据成员处在较大的内存中。这意味着同一个片段中的数据成员并不需要紧密相连，编译器所做的成员对齐就是一个例子。
- 允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。
- 对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。
- 对于虚基类成员也是同样的未予规定。

### 一般的编译器怎么做？

- 同一个Access Section中的数据成员按期声明顺序，依次排列。
- 但成员与成员之间因为内存对齐的原因可能存在空当。
- 多个Access Section按其声明顺序排放。
- 基类的数据成员总放在自己的数据成员之前，但虚基类除外。

### 编译器合成的成员放在哪？

为了实现虚函数和虚拟继承两个功能，编译器一般会合成Vptr和Vbptr两个指针。那么这两个指针应该放在什么位置？C++标准肯定是不曾规定的，因为它甚至并没有规定如何来实现这两个功能，因此就语言层面来看是不存在这两个指针的。

对于Vptr来说有的编译器将它放在末尾，如Lippman领导开发的Cfront。有的则将其放在最前面，如MS的VC，但似乎没人将它放在中间。为什么不放在中间？没有理由可以让人这么做，放在末尾，可以保持C++类对C的struct的良好兼容性，放在最前可以给多重继承下的指针或引用调用虚函数带来好处。

看一小段代码：

```
class X{
public:
    int a;
    virtual void vfc(){};
};
int main()
{
    using namespace std;
    X x;
    cout<<&x.a<<" "<<&x<<endl;
    system("pause");
}
```
在VS2010和VC6.0中运行的结果都是地址值&x.a比&x大4，可见说vc的vptr放在对象的最前面此言非虚。

对于Vbptr来说，有好几种方法，在这儿我们只看看VC的实现原理：

对于由虚拟继承而得的类，VC会在其每一个对象中插入一个Vbptr,这个Vbptr指向vitual base class table（我称之为虚基类表）。虚基类表中则存放有其虚基类子对象相对于虚基类指针的偏移量。例如声明如class Y:virtual public X的类的virtual base class table的虚基类表中当存储有X对象相对于Vbptr的偏移量。

对象成员或基类对象成员后面的填充空白不能为其它成员所用

看一段代码：

```
class X{
public:
    int x;
    char c;
};
class X2:public X
{
public:char  c2;
};
```
X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？

```
X2 x2;
X x;
x2=x;
```
如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。

Vptr与Vbptr^注1

- 在多继承情况下，即使是多虚拟继承，继承而得的类只需维护一个Vbptr；而多继承情况下Vptr则可能有要维护多个Vptr，视其基类有几个有虚函数。
- 一条继承线路只有一个Vptr，但可能有多个Vbptr，视有几次虚拟继承而定。换言之，对于一个继承类对象来说，不需要新合成vptr，而是使用其基类子对象的vptr。而对于一个虚拟继承类来说，必须新合成一个自己的Vbptr。
如：

```
class X{
    virtual void vf(){};
};
class X2:virtual public X
{
    virtual void vf(){};
};
class X3:virtual public  X2
{
     virtual void vf(){};
}
```
X3将包含有一个Vptr，两个Vbptr。确切的说这两个Vbptr一个属于X3，一个属于X3的子对象X2,X3通过其Vbptr找到子对象X2，而X2通过其Vbptr找到X。

其中差别在于vptr通过一个虚函数表可以确切地知道要调用的函数，而Vbptr通过虚基类表只能够知道其虚基类子对象的偏移量。这两条规则是由虚函数与虚拟继承的实现方式，以及受它们的存取方式和复制控制的要求决定的。

### 数据成员的存取

静态数据成员相当于一个仅对该类可见的全局变量，因为程序中只存在一个静态数据成员的实例，所以其地址在编译时就已经被决定。不论如何静态数据成员的存取不会带来任何额外负担。

非静态数据成员的存取，相当于对象起始地址加上偏移量。效率上与C struct成员的效率等同。因为它的偏移量在编译阶段已经确定。但有一种情况例外：pt->x=0.0。当通过指针或引用来存取——x而x又是虚基类的成员的时候。因为必须要等到执行期才能知道pt指向的确切类型，所以必须通过一个间接导引才能完成。

### 小结

在VC中数据成员的布局顺序为：

- vptr部分（如果基类有，则继承基类的）
- vbptr （如果需要）
- 基类成员（按声明顺序）
- 自身数据成员
- 虚基类数据成员（按声明顺序）

### 参考：《深度探索C++对象模型》

